\section{Introduction}
Runtime Verification (RV) is a lightweight formal method to ensure at execution time that a system meets a desirable behaviour. A possible approach for RV consists in analyze an execution trace of the system under scrutiny using a decision procedure called \textit{monitor}. The desirable behaviour of the system can be specified as a set of properties to be verified. From each property a monitor is generated, which primary goal is to detect violation or satisfaction with respect to the given specification, emitting verdicts (truth values) indicating satisfaction or violation of the property ~\cite{rv2,rv3,rvart}.  

There a few different specifications languages to specify monitors for RV, and comparing the expressiveness is these languages is not straightforward. Besides, sometimes it is not easy to select a specific language to write a specification, because the syntax and operations of a particular language may make certain specifications easier or harder to write and/or read ~\cite{rv2,rvart}. 

Some work has being done in translation between languages, for instance the translation of first-order temporal logic into quantified event automata. However, the present work will focus on the translation between Regular Expressions (RE) and Finite State Machine (FSM), two different specification languages to write the RV properties.

There are already algorithms to convert between RE and FSM, and they will be summarized in the present work. However, the algorithms to go from RE to FSM and the one to go from FSM to RE are not inverse. This means that given a RE we can obtain its corresponding FSM, but going back to RE can output a completely different RE. 

When reasoning about the translation of properties between different language specifications would be useful that small changes in one resulted in small changes in another. For a simple example, given the RE (ab*$|$ba*), when one editing on the corresponding FSM just one of the branches of the RE, then when coming back again to the RE only that branch should have been updated. 

\begin{center}
    \textit{``The art of progress is to preserve order amid change and to preserve change amid order''}
\end{center}

\begin{flushright}
    A N Whitehead
\end{flushright}

This is the main motivation to use Bidirectional Transformations (BX) to translate between RE and FSM. BX provide a mechanism to maintain consistency between two pieces of data, the \textit{source} and the \textit{view}. The \textit{get} function extracts part of the information from the source and produces a view, while the \textit{put} function takes the original source and a (possibly) updated view and produces the updated source. The BX must satisfy well-behavedness rules such as \textit{putting} an unmodified view into a source must produce the original source. But besides that, we want to explore the least-changes principle, which states that ``small'' changes on the view lead to ``small'' changes on the source, a topic which is still unsettled and actively investigated by the BX community.


